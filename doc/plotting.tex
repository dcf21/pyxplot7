% PLOTTING.TEX
%
% The documentation in this file is part of PyXPlot
% <http://www.pyxplot.org.uk>
%
% Copyright (C) 2006-7 Dominic Ford <coders@pyxplot.org.uk>
%               2008   Ross Church
%
% $Id$
%
% PyXPlot is free software; you can redistribute it and/or modify it under the
% terms of the GNU General Public License as published by the Free Software
% Foundation; either version 2 of the License, or (at your option) any later
% version.
%
% You should have received a copy of the GNU General Public License along with
% PyXPlot; if not, write to the Free Software Foundation, Inc., 51 Franklin
% Street, Fifth Floor, Boston, MA  02110-1301, USA

% ----------------------------------------------------------------------------

% LaTeX source for the PyXPlot Users' Guide

\chapter{Advanced Plotting}

In this chapter, we continue to explore the various options of the {\tt plot}
command. Specifically, we turn to those aspects which differ from gnuplot's
{\tt plot} command.

\section{A Tour of PyXPlot's Plot Styles}

We begin by reviewing the various plot styles which are available in PyXPlot.
Two of these we have already met: {\tt lines}, which draws straight lines
between data points, and {\tt points}, which does not connect data points.

\subsection{Lines and Points}

The following are PyXPlot's most basic plot styles\footnote{This is not an
exhaustive list; see Section~\ref{list_of_plotstyles} for such a list.}:
\begin{itemize}
\item \indpst{dots} -- places a small dot at each datum
\item \indpst{points} -- places a marker symbol at each datum
\item \indpst{lines} -- connects the data with lines
\item \indpst{linespoints} -- a combination of both lines and points
\end{itemize}

When using the \indpst{points}, \indpst{linespoints} and \indpst{dots} plot
styles, the size of the plotted points or dots can be varied by using the
\indmodt{pointsize} modifier. In each case, the default value of these settings
is $1.0$. For example, to represent data with large dots, the following would
be used:

\begin{verbatim}
plot sin(x) with dots pointsize 10
\end{verbatim}

\noindent The width of lines can similarly be controlled with the
\indmodt{linewidth} modifier, and the width of the lines used to draw point
symbols can be controlled with the \indmodt{pointlinewidth} modifier. For
example:

\begin{verbatim}
plot sin(x) with points pointlinewidth 2
\end{verbatim}

\noindent In addition to setting these parameters on a per-plot basis, their
default values can also be changed. The command:

\begin{verbatim}
{\tt set pointlinewidth 2}
\end{verbatim}

\noindent will set the default linewidth used when drawing data points. Both
here, and in the {\tt plot} command, the abbreviation {\tt plw} is valid. 

\subsection{Upper and Lower Limit Data Points}

PyXPlot can plot datapoints using the standard upper- and lower-limit
symbols.\index{lower-limit datapoints}\index{upper-limit datapoints} No special
syntax is required for this; these symbols are pointtypes\footnote{The
{\tt pointtype} modifier was introduced in
Section~\ref{pointtype_modifier}.} 12 and 13 respectively, obtained as follows:

\begin{verbatim}
plot 'upperlimits.dat' with points pointtype 12
plot 'lowerlimits.dat' with points pointtype 13
\end{verbatim}

\subsection{Drawing Arrows}
\label{arrows_plot_style} 

Data may be represented as arrows connecting two points on a plot by using the
\indpst{arrows} plot style.  This takes four columns of data, $x_1$, $y_1$,
$x_2$, $y_2$, and for each data point draws an arrow from the point $(x_1,y_1)$
to $(x_2,y_2)$.  Three different kinds of arrows can be drawn: ones with normal
arrow heads, ones with no arrow heads, which just appear as lines, and ones
with arrow heads on both ends. The syntax is:

\begin{verbatim}
plot 'datafile.dat' with arrows_head
plot 'datafile.dat' with arrows_nohead
plot 'datafile.dat' with arrows_twohead
\end{verbatim}

The syntax `{\tt with arrows}' is a shorthand for `{\tt with arrows\_head}'.
This plot style is analogous to the \indpst{vectors} plot style in Version~4 of
Gnuplot.

\subsection{Error Bars}

\index{errorbars}\label{errorbars}
In Gnuplot, when one used errorbars, one could either specify the size of the
errorbar, or the min/max range of the errorbar. Both of these usages shared a
common syntax, and gnuplot's behaviour depended upon the number of data columns
provided:

\begin{verbatim}
plot 'datafile.dat' with yerrorbars
\end{verbatim}

\noindent Given a datafile with three columns, this would take the third column
to indicate the size of the $y$-errorbar. Given a four-column datafile, it
would take the third and fourth columns to indicate the min/max range to be
marked out by the errorbar.

To avoid confusion, a different syntax is adopted in PyXPlot. The syntax:

\begin{verbatim}
plot 'datafile.dat' with yerrorbars
\end{verbatim}

\noindent now always assumes the third column of the datafile to indicate the
size of the errorbar, regardless of whether a fourth is present. The syntax:

\begin{verbatim}
plot 'datafile.dat' with yerrorrange
\end{verbatim}

\noindent always assumes the third and fourth columns to indicate the min/max
range of the errorbar.

\vspace{0.5cm}
For clarity, a complete list of errorbar styles available in PyXPlot is given below:

\begin{tabular}{p{2.5cm}p{7.5cm}}
\indpst{yerrorbars} & Vertical errorbars; size drawn from the third data-column. \\
\indpst{xerrorbars} & Horizontal errorbars; size drawn from the third data-column. \\
\indpst{xyerrorbars} & Horizontal and vertical errorbars; sizes drawn from the third and fourth data-columns respectively.\\
\indpst{errorbars} & Shorthand for {\tt yerrorbars}. \\
\end{tabular}

\begin{tabular}{p{2.5cm}p{7.5cm}}
\indpst{yerrorrange} & Vertical errorbars; minimum drawn from the third data-column, maximum from the fourth.\\
\indpst{xerrorrange} & Horizontal errorbars; minimum drawn from the third data-column, maximum from the fourth.\\
\indpst{xyerrorrange} & Horizontal and vertical errorbars; horizontal minimum drawn from the third data-column, and maximum from the fourth; vertical minimum drawn from the fifth, and maximum from the sixth.\\
\indpst{errorrange} & Shorthand for {\tt yerrorrange}. \\
\end{tabular}

\subsection{Plotting Functions with Errorbars, Arrows, or More}

In gnuplot, when a function (as opposed to a datafile) is plotted, only those
plot styles which accept two columns of data can be used -- for example,
{\tt lines} or {\tt points}. This means that it is not possible to plot a
function with errorbars. In PyXPlot, this is possible using the following
syntax:

\begin{verbatim}
plot f(x):g(x) with yerrorbars
\end{verbatim}

\noindent Two functions are supplied, separated by a colon; plotting proceeds
as if a datafile had been supplied, containing values of $x$ in column 1,
values of $f(x)$ in column 2, and values of $g(x)$ in column 3. This may be
useful, for example, if $g(x)$ measures the intrinsic uncertainty in $f(x)$.
The {\tt using} modifier may also be used:

\begin{verbatim}
plot f(x):g(x) using 2:3
\end{verbatim}

Here, $g(x)$ would be plotted on the $y$-axis, against $f(x)$ on the $x$-axis.
It should be noted, however, that the range of values of $x$ used would still
correspond to the range of the plot's horizontal axis. If the above were to be
attempted with an autoscaling horizontal axis, the result might be rather
unexpected -- PyXPlot would find itself autoscaling the $x$-axis range to the
spread of values of $f(x)$, but find that this itself changed depending upon
the range of the $x$-axis.\footnote{We're aware that this is not good. Expect
it to change in a future release.}

\section{Barcharts and Histograms}
\label{barcharts}\index{bar charts}
\index{steps plot style@{\tt steps} plot style}
\index{fsteps plot style@{\tt fsteps} plot style}
\index{histeps plot style@{\tt histeps} plot style}
\index{impulses plot style@{\tt impulses} plot style}

\subsection{Basic Operation}

As in gnuplot, bar charts and histograms can be produced using the
\indpst{boxes} plot style:

\begin{verbatim} 
plot 'datafile.dat' with boxes
\end{verbatim}

\noindent Horizontally, the interfaces between the bars are, by default, at the
midpoints along the $x$-axis between the specified datapoints (see, for
example, Figure~\ref{fig:ex_barchart2}a).  Alternatively, the widths of the
bars may be set using the {\tt set boxwidth} command. In this case, all of
the bars will be centred upon their specified $x$-coordinates, and have total
widths equalling that specified in the \indcmdt{set boxwidth}. Consequently, there may be
gaps between them, or they may overlap, as seen in
Figure~\ref{fig:ex_barchart2}(c).

\begin{figure}
\begin{center}
\includegraphics{examples/eps/ex_barchart2.eps}
\end{center}
\caption{A gallery of different bar chart styles which PyXPlot can produce. See the text for more details.}
\label{fig:ex_barchart2}
\end{figure}

Having set a fixed box width, the default behaviour of scaling box widths
automatically may be restored either with the {\tt unset boxwidth} command,
or by setting the boxwidth to a negative width.

As a third alternative, it is also possible to specify different widths for
each bar manually, in a column of the input datafile. To achieve this
behaviour, the \indpst{wboxes} plot style should be used:

\begin{verbatim} 
plot 'datafile.dat' using 1:2:3 with wboxes
\end{verbatim}

\noindent This plot style expects three columns of data to be specified: the
$x$- and $y$-coordinates of each bar in the first two, and the width of the
bars in the third.  Figure~\ref{fig:ex_barchart2}(b) shows an example of this
plot style in use.

By default, the bars originate from the line $y=0$, as is normal for a
histogram. However, should it be desired for the bars to start from a different
vertical point, this may be achieved by using the \indcmdt{set boxfrom},
for example:

\begin{verbatim} 
set boxfrom 5
\end{verbatim}

\noindent In this case, all of the bars would now originate from the line
$y=5$. Figure~\ref{fig:ex_barchart1}(f) shows the kind of effect that is
achieved; for comparison, Figure~\ref{fig:ex_barchart1}(b) shows the same bar
chart with the boxes starting from their default position of $y=0$.

\begin{figure}
\begin{center}
\includegraphics{examples/eps/ex_barchart1.eps}
\end{center}
\caption{A second gallery of different bar chart styles which PyXPlot can produce. See the text for more details.}
\label{fig:ex_barchart1}
\end{figure}

The bars may be filled using the {\tt with} \indmodt{fillcolour} modifier,
followed by the name of a colour:

\begin{verbatim} 
plot 'datafile.dat' with boxes fillcolour blue
plot 'datafile.dat' with boxes fc 4
\end{verbatim}

\noindent Figures~\ref{fig:ex_barchart2}(c) and (d) demonstrate the use of
filled bars.

Finally, the \indpst{impulses} plot style, as in gnuplot, produces bars of zero
width; see Figure~\ref{fig:ex_barchart1}(e) for an example.

\subsection{Stacked Bar Charts}

If several datapoints are supplied to the \indpst{boxes} or \indpst{wboxes}
plot styles at a common $x$-coordinate, then the bars are stacked one above
another into a stacked barchart. Consider the following datafile:

\begin{verbatim} 
1 1
2 2
2 3
3 4
\end{verbatim}

\noindent The second bar at $x=2$ would be placed on top of the first, spanning
the range $2<y<5$, and having the same width as the first. If plot colours are
being automatically selected from the palette, then a different palette colour
is used to plot the upper bar.

\subsection{Steps}

The plot styles met so far plot data as solid bars, with left, right and top
sides all drawn. Data may also be plotted with {\it steps}, with the left and
right sides of each bar omitted. Some examples are shown in
Figures~\ref{fig:ex_barchart1}(a), (c) and (d).  As is illustrated in these
panels, three flavours of steps are available, exactly as in gnuplot:

\begin{verbatim}
plot 'datafile.dat' with steps 
plot 'datafile.dat' with fsteps 
plot 'datafile.dat' with histeps
\end{verbatim}

When using the \indpst{steps} plot style, the datapoints specify the right-most
edges of each step. When using the \indpst{fsteps} plot style, they specify the
left-most edges of the steps. The \indpst{histeps} plot style works rather like
the {\tt boxes} plot style; the interfaces between the steps occur at the
horizontal midpoints between the datapoints.

\section{Choosing which data to plot}
\label{select_modifier} 
As well as the {\tt index}, {\tt using} and {\tt every} keywords which allow
users to plot subsets of data from datafiles, PyXPlot also has a further
modifier, \indmodt{select}. This can be used to plot only those datapoints in a
datafile which specify some given criterion. For example:

\begin{verbatim}
plot 'datafile.dat' select ($8>5)
plot sin(x) select (($1>0) and ($2>0))
\end{verbatim}

In the second example, two select criteria are given, combined with the logical
{\tt and} operator. A full list of all of the operators recognised by PyXPlot
was given in Chapter~2; see Table~\ref{operators_table}.  The select modifier
has many applications, for example, plotting two-dimensional slices from
three-dimensional datasets and selecting certain subsets of datapoints from a
datafile for plotting.

\section{Horizontally arranged datafiles}

\index{horizontal datafiles}\index{datafiles!horizontal}\index{using rows
modifier@{\tt using rows} modifier}\index{using columns modifier@{\tt using
columns} modifier}\label{horizontal_datafiles} The command syntax for plotting
columns of datafiles against one another was previously described in
Section~\ref{plot_datafiles}.  In an extension of what is possible in gnuplot,
PyXPlot also allows one to plot {\it rows} of data against one another in
horizontally-arranged datafiles.  For this, the keyword {\tt rows} is placed
after the {\tt using} modifier:\index{rows keyword@{\tt rows} keyword}

\begin{verbatim}
plot 'datafile.dat' index 1 using rows 1:2
\end{verbatim}

\noindent For completeness, the syntax {\tt using columns} is also
accepted, to specify the default behaviour of plotting columns against one
another:\index{columns keyword@{\tt columns} keyword}

\begin{verbatim}
plot 'datafile.dat' index 1 using columns 1:2
\end{verbatim}

When plotting horizontally-arranged datafiles, the meanings of the
{\tt index} and {\tt every} modifiers (see Section~\ref{plot_datafiles})
are altered slightly. The former continues to refer to vertically-displaced
blocks of data separated by two blank lines.  Blocks, as referenced in the
{\tt every} modifier, likewise continue to be vertically-displaced blocks of
datapoints, separated by single blank lines. The row numbers passed to the
{\tt using} modifier are counted from the top of the current block.

However, the line-numbers specified in the \indmodt{every} modifier -- i.e.
variables $a$, $c$ and $e$ in the system introduced in
Section~\ref{introduce_every} -- now refer to horizontal columns, rather than
lines. For example:

\begin{verbatim}
plot 'datafile.dat' using rows 1:2 every 2::3::9
\end{verbatim}

\noindent would plot the data in row 2 against that in row 1, using only the
values in every other column, between columns 3 and 9.

\section{Configuring Axes}
\label{axis_extensions}\label{ranges_multiaxes}\label{multiple_axes}

By default, plots have only one $x$-axis and one $y$-axis. Further parallel
axes can be added and configured via statements such as:\index{axes
modifier@{\tt axes} modifier}\indcmd{set axis}

\begin{verbatim}
set x3label 'foo'
plot sin(x) axes x3y1
set axis x3
\end{verbatim}

\noindent In the top statement, a further-$x$ axis, called the $x3$-axis, is
implicitly created by giving it a label. In the next, the {\tt axes}
modifier is used to tell the {\tt plot} command to plot data using the
$x3$-axis. Here again, the axis would be implicitly created if it didn't
already exist.  In the third statement, an $x3$-axis is explicitly created.

Unlike gnuplot, which allowed only a maximum of two parallel axes to be added
to plots, PyXPlot allows an unlimited number of axes to be used. Odd-numbered
$x$-axes appear below the plot, and even numbered $x$-axes above it; a similar
rule applies for $y$-axes, to the left and to the right. This is illustrated in
Figure~\ref{fig:ex_multiaxes}.

\begin{figure}
\begin{center}
\includegraphics{examples/eps/ex_multiaxes.eps}
\end{center}
\caption{A plot demonstating the use of large numbers of axes. Odd-numbered
$x$-axes appear below the plot, and even numbered $x$-axes above it; a similar
rule applies for $y$-axes, to the left and to the right.}
\label{fig:ex_multiaxes}
\end{figure}

As discussed in the previous chapter, the ranges of axes can be set either
using the \indcmdt{set xrange}, or within the {\tt plot} command. The following
two statements would set equivalent ranges for the $x3$-axis:

\begin{verbatim}
set x3range [-2:2]
plot [:][:][:][:][-2:2] sin(x) axes x3y1
\end{verbatim}

\noindent As usual, the first two ranges specified in the {\tt plot} command
apply to the $x$- and $y$-axes. The next pair apply to the $x2$- and $y2$-axes,
and so forth.

\index{axes!removal}\index{removing axes}\index{hidden
axes}\label{axis_removal} Having made axes with the above commands, they may
subsequently be removed using the \indcmdt{unset axis} as follows:

\begin{verbatim}
unset axis x3
unset axis x3x5y3 y7
\end{verbatim}

\noindent The top statement, for example, would remove axis $x3$. The command
{\tt unset axis} on its own, with no axes specified, returns all axes to
their default configuration.  The special case of {\tt unset axis x1} does
not remove the first $x$-axis -- it cannot be removed -- but instead returns it
to its default configuration.

It should be noted that if the following two commands are typed in succession,
the second may not entirely negate the first:

\begin{verbatim}
set x3label 'foo'
unset x3label 'foo'
\end{verbatim}

\noindent If an $x3$-axis did not previously exist, then the first will have
implicitly created one. This would need to be removed with the {\tt unset
axis x3} command if it was not desired.

A subtly different task is that of removing labels from axes, or setting axes
not to display. To achieve this, a number of special axis labels are used.
Labelling an axis ``{\tt nolabels}''\index{nolabels
keyword@{\tt nolabels} keyword} has the effect that no title or numerical
labels are placed upon it. Labelling it\label{nolabelstics}
``{\tt nolabelstics}''\index{nolabelstics keyword@{\tt nolabelstics}
keyword} is stronger still; this removes all tick marks from it as well
(similar in effect to the {\tt set noxtics} command; see below). Finally,
labelling it ``{\tt invisible}''\index{invisible keyword@{\tt invisible}
keyword} makes an axis completely invisible.

Labels may be placed on such axes, by following the magic keywords above with a
colon and the desired title, for example:

\begin{verbatim}
set xlabel 'nolabels:Time'
\end{verbatim}

\noindent would produce an $x$-axis with no numeric labels, but a label of
`Time'.

In the unlikely event of wanting
to label a normal axis with one of these magic words\index{axes!reserved
labels}\index{magic axis labels}, this may be achieved by prefixing the magic
word with a space. There is one further magic axis label, {\tt linkaxis},
which will be described in Section~\ref{linked_axes}.

The ticks of axes can be configured to point either inward, towards the plot,
as is the default, or outward towards the axis labels, or in both directions.
This is achieved using the {\tt set xticdir} command, for example:

\begin{verbatim}
set xticdir inward
set y2ticdir outward
set x2ticdir both
\end{verbatim}

The position of ticks along each axis can be configured with the \indcmdt{set
xtics}. The appearance of ticks along any axis can be turned off with the
\indcmdt{set noxtics}. The syntax for these is given below:

\begin{verbatim}
set xtics { axis | border | inward | outward | both }
          {  autofreq
           | <increment>
           | <minimum>, <increment> { , <maximum> }
           | (     {"label"} <position>
               { , {"label"} <position> } .... )
          }
set noxtics
show xtics
\end{verbatim}

The keywords {\tt inward}, {\tt outward} and {\tt both} alter the
directions of the ticks, and have the same effect as in the {\tt set
xticdir} command. The keyword {\tt axis} is an alias for {\tt inward},
and {\tt border} an alias for {\tt outward}, both provided for
compatibility with gnuplot. If the keyword {\tt autofreq} is given, the automatic
placement of ticks on the axis is restored.

If {\tt <minimum>, <increment>, <maximum>} are specified, then ticks are
placed at evenly spaced intervals between the specified limits. In the case of
logarithmic axes, {\tt <increment>} is applied multiplicatively.

Alternatively, the final form allows ticks to be placed on an axis
individually, and each given its own textual label.

The following pair of examples would both place tick marks at $x=2$, 3, 4 and~5.
In the second example, they would be labelled `a', `b', `c' and `d':

\begin{verbatim}
set xtics 2, 1, 5

set x2tics ("a" 2, "b" 3, "c" 4, "d" 5)
\end{verbatim}

The following example would place tick marks at intervals of two units along
the $x3$-axis:

\begin{verbatim}
set x3tics 2
\end{verbatim}

The following example would restore the automatic placement of ticks along the
$x4$-axis, placing those ticks facing outwards from the graph:

\begin{verbatim}
set x4tics border autofreq
\end{verbatim}

\begin{figure}
\begin{center}
\includegraphics{examples/eps/ex_axistics.eps}
\end{center}
\caption{A plot demonstrating the use of the {\tt set xtics} command. The commands used to create the axes in this plot are as given in the text.}
\label{fig:ex_axistics}
\end{figure}


All of the examples above are illustrated in Figure~\ref{fig:ex_axistics}.
Minor tick marks can be placed on axes with the {\tt set mxtics} command,
which has the same syntax as above.

\section{Keys and Legends}

By default, plots are displayed with legends in their top-right corners. The
textual description of each dataset is drawn by default from the command used
to plot it. Alternatively, the user may specify his own description for each
dataset by following the {\tt plot} command with the \indmodt{title} modifier,
as follows:

\begin{verbatim}
plot sin(x) title 'A sine wave'
plot cos(x) title ''
\end{verbatim}

In the lower case, a blank title is specified, in which case PyXPlot makes no
entry for this dataset in the legend. This is useful if it is desired to place
some but not all datasets into the legend of a plot.  Alternatively, the
production of the legend can be completely turned off for all datasets, by the
command \indcmdts{set nokey}. The opposite effect can be achieved by the
\indcmdt{set key} command.

This latter command can also be used to dictate where on the plot the legend
should be placed, using a syntax along the lines of:

\begin{verbatim}
set key top right
\end{verbatim}

The following recognised positioning keywords are self-explanatory:
{\tt top}, {\tt bottom}, {\tt left}, {\tt right}, {\tt xcentre}
and {\tt ycentre}. The word {\tt outside} places the key outside the
plot, on its right side. The words {\tt below} and {\tt above} places
legends below and above the plot respectively.

In addition, two positional offset coordinates may be specified after such
keywords -- the first value is assumed to be an $x$-offset, and the second a
$y$-offset, in units of centimetres. For example:

\begin{verbatim}
set key bottom left 0.0 -0.5
\end{verbatim}

\noindent would display a key below the bottom left corner of the graph.

By default, entries in the key are placed in a single vertical list. They can
instead be arranged into a number of columns by means of the \indcmdt{set
keycolumns}. This should be followed by the integer number of desired columns,
for example:

\begin{verbatim}
set keycolumns 2
\end{verbatim}

\noindent An example of a plot with a two-column legend is given in
Figure~\ref{fig:ex_legends}.

\begin{figure}
\begin{center}
\includegraphics{examples/eps/ex_legends.eps}
\end{center}
\caption{An example of a plot with a two-column legend, positioned below the plot using {\tt set key below}.}
\label{fig:ex_legends}
\end{figure}

\section{The {\tt linestyle} Keyword}

At times, the string of style keywords placed after the {\tt with} modifier
in {\tt plot} commands can grow rather unwieldy in its length. For clarity,
frequently used plot styles can be stored as {\it linestyles}; despite the name,
this is true of styles involving points as well as lines. The syntax for
setting a linestyle is:

\begin{verbatim}
set linestyle 2 points pointtype 3
\end{verbatim}

\noindent where the {\tt 2} is the identification number of the linestyle. In a
subsequent {\tt plot} statement, this linestyle can be recalled as follows:

\begin{verbatim}
plot sin(x) with linestyle 2
\end{verbatim}

\section{Colour Plotting}

\index{colours!setting for datasets} In the {\tt with} clause of the plot
command, the modifier {\tt colour}, which can be abbreviated to
`{\tt c}', can be used to manually select the colour in which each dataset
is to be plotted. It should be followed either by an integer, to set a colour
from the present palette, or by a colour name. A list of valid colour names is
given in Section~\ref{colour_names}. For example:

\begin{verbatim}
plot sin(x) with c 5
plot sin(x) with colour blue
\end{verbatim}

\noindent The {\tt colour} modifier can also be used when defining linestyles.

\index{colours!setting the palette} PyXPlot has a palette of colours which it
assigns sequentially to datasets when colours are not manually assigned. This
is also the palette to which integers passed to {\tt set colour} refer -- the
{\tt 5} above, for example. It may be set using the \indcmdt{set palette},
which differs in syntax from gnuplot. It should be followed by a
comma-separated list of colours, for example:

\begin{verbatim}
set palette red,green,blue
\end{verbatim}

Another way of setting the palette, in a configuration file, is described in
Section~\ref{config_files}; a list of valid colour names is given in
Section~\ref{colour_names}.

\section{Plotting Many Files at Once}

\index{globbing}\index{wildcards}\index{datafiles!globbing}

PyXPlot allows the wildcards `*' and `?' to be used both in the filenames of
datafiles following the \indcmdt{plot}, and also when specifying command files
on the command line and with the \indcmdt{load}. For example, the following
would plot all datafiles in the current directory with a `.dat' suffix, using
the same plot options:

\begin{verbatim}
plot '*.dat' with linewidth 2
\end{verbatim}

In the legend, full filenames are displayed, allowing the datafiles to be
distinguished.  As in gnuplot, a blank filename passed to the plot command
causes the last used datafile to be used again.

\section{Backing Up Over-Written Files}

\index{overwriting files}\index{backup files}\label{filebackup}

By default, when plotting to a file, if the output filename matches that of an
existing file, that file is overwritten. This behaviour may be changed with the
\indcmdt{set backup}, which has syntax:

\begin{verbatim}
set backup
set nobackup
\end{verbatim}

When this switch is turned on, pre-existing files will be renamed with a tilde
at the end of their filenames, rather than being overwritten.

